// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: Storage.proto

package storage

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TaskConfigService_CreateTask_FullMethodName = "/storage.TaskConfigService/CreateTask"
	TaskConfigService_GetTask_FullMethodName    = "/storage.TaskConfigService/GetTask"
	TaskConfigService_UpdateTask_FullMethodName = "/storage.TaskConfigService/UpdateTask"
	TaskConfigService_DeleteTask_FullMethodName = "/storage.TaskConfigService/DeleteTask"
	TaskConfigService_ListTasks_FullMethodName  = "/storage.TaskConfigService/ListTasks"
)

// TaskConfigServiceClient is the client API for TaskConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskConfigServiceClient interface {
	// 任务管理
	CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error)
	GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error)
	UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error)
	DeleteTask(ctx context.Context, in *DeleteTaskRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	ListTasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaskListResponse, error)
}

type taskConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskConfigServiceClient(cc grpc.ClientConnInterface) TaskConfigServiceClient {
	return &taskConfigServiceClient{cc}
}

func (c *taskConfigServiceClient) CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResponse)
	err := c.cc.Invoke(ctx, TaskConfigService_CreateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskConfigServiceClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResponse)
	err := c.cc.Invoke(ctx, TaskConfigService_GetTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskConfigServiceClient) UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*TaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResponse)
	err := c.cc.Invoke(ctx, TaskConfigService_UpdateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskConfigServiceClient) DeleteTask(ctx context.Context, in *DeleteTaskRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, TaskConfigService_DeleteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskConfigServiceClient) ListTasks(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TaskListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskListResponse)
	err := c.cc.Invoke(ctx, TaskConfigService_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskConfigServiceServer is the server API for TaskConfigService service.
// All implementations must embed UnimplementedTaskConfigServiceServer
// for forward compatibility.
type TaskConfigServiceServer interface {
	// 任务管理
	CreateTask(context.Context, *CreateTaskRequest) (*TaskResponse, error)
	GetTask(context.Context, *GetTaskRequest) (*TaskResponse, error)
	UpdateTask(context.Context, *UpdateTaskRequest) (*TaskResponse, error)
	DeleteTask(context.Context, *DeleteTaskRequest) (*DeleteResponse, error)
	ListTasks(context.Context, *Empty) (*TaskListResponse, error)
	mustEmbedUnimplementedTaskConfigServiceServer()
}

// UnimplementedTaskConfigServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskConfigServiceServer struct{}

func (UnimplementedTaskConfigServiceServer) CreateTask(context.Context, *CreateTaskRequest) (*TaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTask not implemented")
}
func (UnimplementedTaskConfigServiceServer) GetTask(context.Context, *GetTaskRequest) (*TaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTask not implemented")
}
func (UnimplementedTaskConfigServiceServer) UpdateTask(context.Context, *UpdateTaskRequest) (*TaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTask not implemented")
}
func (UnimplementedTaskConfigServiceServer) DeleteTask(context.Context, *DeleteTaskRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTask not implemented")
}
func (UnimplementedTaskConfigServiceServer) ListTasks(context.Context, *Empty) (*TaskListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedTaskConfigServiceServer) mustEmbedUnimplementedTaskConfigServiceServer() {}
func (UnimplementedTaskConfigServiceServer) testEmbeddedByValue()                           {}

// UnsafeTaskConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskConfigServiceServer will
// result in compilation errors.
type UnsafeTaskConfigServiceServer interface {
	mustEmbedUnimplementedTaskConfigServiceServer()
}

func RegisterTaskConfigServiceServer(s grpc.ServiceRegistrar, srv TaskConfigServiceServer) {
	// If the following call pancis, it indicates UnimplementedTaskConfigServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskConfigService_ServiceDesc, srv)
}

func _TaskConfigService_CreateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskConfigServiceServer).CreateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskConfigService_CreateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskConfigServiceServer).CreateTask(ctx, req.(*CreateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskConfigService_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskConfigServiceServer).GetTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskConfigService_GetTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskConfigServiceServer).GetTask(ctx, req.(*GetTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskConfigService_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskConfigServiceServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskConfigService_UpdateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskConfigServiceServer).UpdateTask(ctx, req.(*UpdateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskConfigService_DeleteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskConfigServiceServer).DeleteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskConfigService_DeleteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskConfigServiceServer).DeleteTask(ctx, req.(*DeleteTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskConfigService_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskConfigServiceServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskConfigService_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskConfigServiceServer).ListTasks(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskConfigService_ServiceDesc is the grpc.ServiceDesc for TaskConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "storage.TaskConfigService",
	HandlerType: (*TaskConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTask",
			Handler:    _TaskConfigService_CreateTask_Handler,
		},
		{
			MethodName: "GetTask",
			Handler:    _TaskConfigService_GetTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _TaskConfigService_UpdateTask_Handler,
		},
		{
			MethodName: "DeleteTask",
			Handler:    _TaskConfigService_DeleteTask_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _TaskConfigService_ListTasks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Storage.proto",
}

const (
	ReportService_GetReport_FullMethodName    = "/storage.ReportService/GetReport"
	ReportService_ListReports_FullMethodName  = "/storage.ReportService/ListReports"
	ReportService_DeleteReport_FullMethodName = "/storage.ReportService/DeleteReport"
)

// ReportServiceClient is the client API for ReportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReportServiceClient interface {
	// 测试报告
	GetReport(ctx context.Context, in *GetTestReportRequest, opts ...grpc.CallOption) (*TestReportResponse, error)
	ListReports(ctx context.Context, in *GetTaskReportListRequest, opts ...grpc.CallOption) (*ReportListResponse, error)
	DeleteReport(ctx context.Context, in *GetTestReportRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type reportServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReportServiceClient(cc grpc.ClientConnInterface) ReportServiceClient {
	return &reportServiceClient{cc}
}

func (c *reportServiceClient) GetReport(ctx context.Context, in *GetTestReportRequest, opts ...grpc.CallOption) (*TestReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestReportResponse)
	err := c.cc.Invoke(ctx, ReportService_GetReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) ListReports(ctx context.Context, in *GetTaskReportListRequest, opts ...grpc.CallOption) (*ReportListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportListResponse)
	err := c.cc.Invoke(ctx, ReportService_ListReports_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reportServiceClient) DeleteReport(ctx context.Context, in *GetTestReportRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, ReportService_DeleteReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReportServiceServer is the server API for ReportService service.
// All implementations must embed UnimplementedReportServiceServer
// for forward compatibility.
type ReportServiceServer interface {
	// 测试报告
	GetReport(context.Context, *GetTestReportRequest) (*TestReportResponse, error)
	ListReports(context.Context, *GetTaskReportListRequest) (*ReportListResponse, error)
	DeleteReport(context.Context, *GetTestReportRequest) (*DeleteResponse, error)
	mustEmbedUnimplementedReportServiceServer()
}

// UnimplementedReportServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReportServiceServer struct{}

func (UnimplementedReportServiceServer) GetReport(context.Context, *GetTestReportRequest) (*TestReportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReport not implemented")
}
func (UnimplementedReportServiceServer) ListReports(context.Context, *GetTaskReportListRequest) (*ReportListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReports not implemented")
}
func (UnimplementedReportServiceServer) DeleteReport(context.Context, *GetTestReportRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReport not implemented")
}
func (UnimplementedReportServiceServer) mustEmbedUnimplementedReportServiceServer() {}
func (UnimplementedReportServiceServer) testEmbeddedByValue()                       {}

// UnsafeReportServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReportServiceServer will
// result in compilation errors.
type UnsafeReportServiceServer interface {
	mustEmbedUnimplementedReportServiceServer()
}

func RegisterReportServiceServer(s grpc.ServiceRegistrar, srv ReportServiceServer) {
	// If the following call pancis, it indicates UnimplementedReportServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReportService_ServiceDesc, srv)
}

func _ReportService_GetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTestReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).GetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_GetReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).GetReport(ctx, req.(*GetTestReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_ListReports_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskReportListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).ListReports(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_ListReports_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).ListReports(ctx, req.(*GetTaskReportListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReportService_DeleteReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTestReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReportServiceServer).DeleteReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReportService_DeleteReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReportServiceServer).DeleteReport(ctx, req.(*GetTestReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReportService_ServiceDesc is the grpc.ServiceDesc for ReportService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReportService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "storage.ReportService",
	HandlerType: (*ReportServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetReport",
			Handler:    _ReportService_GetReport_Handler,
		},
		{
			MethodName: "ListReports",
			Handler:    _ReportService_ListReports_Handler,
		},
		{
			MethodName: "DeleteReport",
			Handler:    _ReportService_DeleteReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Storage.proto",
}

const (
	TestDataService_CreateTestData_FullMethodName = "/storage.TestDataService/CreateTestData"
	TestDataService_GetTestData_FullMethodName    = "/storage.TestDataService/GetTestData"
	TestDataService_UpdateTestData_FullMethodName = "/storage.TestDataService/UpdateTestData"
	TestDataService_DeleteTestData_FullMethodName = "/storage.TestDataService/DeleteTestData"
	TestDataService_ListTestData_FullMethodName   = "/storage.TestDataService/ListTestData"
)

// TestDataServiceClient is the client API for TestDataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TestDataServiceClient interface {
	// 测试数据
	CreateTestData(ctx context.Context, in *CreateTestDataRequest, opts ...grpc.CallOption) (*TestDataResponse, error)
	GetTestData(ctx context.Context, in *GetTestDataRequest, opts ...grpc.CallOption) (*TestDataResponse, error)
	UpdateTestData(ctx context.Context, in *UpdateTestDataRequest, opts ...grpc.CallOption) (*TestDataResponse, error)
	DeleteTestData(ctx context.Context, in *DeleteTestDataRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	ListTestData(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TestDataListResponse, error)
}

type testDataServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTestDataServiceClient(cc grpc.ClientConnInterface) TestDataServiceClient {
	return &testDataServiceClient{cc}
}

func (c *testDataServiceClient) CreateTestData(ctx context.Context, in *CreateTestDataRequest, opts ...grpc.CallOption) (*TestDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestDataResponse)
	err := c.cc.Invoke(ctx, TestDataService_CreateTestData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testDataServiceClient) GetTestData(ctx context.Context, in *GetTestDataRequest, opts ...grpc.CallOption) (*TestDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestDataResponse)
	err := c.cc.Invoke(ctx, TestDataService_GetTestData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testDataServiceClient) UpdateTestData(ctx context.Context, in *UpdateTestDataRequest, opts ...grpc.CallOption) (*TestDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestDataResponse)
	err := c.cc.Invoke(ctx, TestDataService_UpdateTestData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testDataServiceClient) DeleteTestData(ctx context.Context, in *DeleteTestDataRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, TestDataService_DeleteTestData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testDataServiceClient) ListTestData(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TestDataListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestDataListResponse)
	err := c.cc.Invoke(ctx, TestDataService_ListTestData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestDataServiceServer is the server API for TestDataService service.
// All implementations must embed UnimplementedTestDataServiceServer
// for forward compatibility.
type TestDataServiceServer interface {
	// 测试数据
	CreateTestData(context.Context, *CreateTestDataRequest) (*TestDataResponse, error)
	GetTestData(context.Context, *GetTestDataRequest) (*TestDataResponse, error)
	UpdateTestData(context.Context, *UpdateTestDataRequest) (*TestDataResponse, error)
	DeleteTestData(context.Context, *DeleteTestDataRequest) (*DeleteResponse, error)
	ListTestData(context.Context, *Empty) (*TestDataListResponse, error)
	mustEmbedUnimplementedTestDataServiceServer()
}

// UnimplementedTestDataServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTestDataServiceServer struct{}

func (UnimplementedTestDataServiceServer) CreateTestData(context.Context, *CreateTestDataRequest) (*TestDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTestData not implemented")
}
func (UnimplementedTestDataServiceServer) GetTestData(context.Context, *GetTestDataRequest) (*TestDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTestData not implemented")
}
func (UnimplementedTestDataServiceServer) UpdateTestData(context.Context, *UpdateTestDataRequest) (*TestDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTestData not implemented")
}
func (UnimplementedTestDataServiceServer) DeleteTestData(context.Context, *DeleteTestDataRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTestData not implemented")
}
func (UnimplementedTestDataServiceServer) ListTestData(context.Context, *Empty) (*TestDataListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTestData not implemented")
}
func (UnimplementedTestDataServiceServer) mustEmbedUnimplementedTestDataServiceServer() {}
func (UnimplementedTestDataServiceServer) testEmbeddedByValue()                         {}

// UnsafeTestDataServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TestDataServiceServer will
// result in compilation errors.
type UnsafeTestDataServiceServer interface {
	mustEmbedUnimplementedTestDataServiceServer()
}

func RegisterTestDataServiceServer(s grpc.ServiceRegistrar, srv TestDataServiceServer) {
	// If the following call pancis, it indicates UnimplementedTestDataServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TestDataService_ServiceDesc, srv)
}

func _TestDataService_CreateTestData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTestDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestDataServiceServer).CreateTestData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestDataService_CreateTestData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestDataServiceServer).CreateTestData(ctx, req.(*CreateTestDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestDataService_GetTestData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTestDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestDataServiceServer).GetTestData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestDataService_GetTestData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestDataServiceServer).GetTestData(ctx, req.(*GetTestDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestDataService_UpdateTestData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTestDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestDataServiceServer).UpdateTestData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestDataService_UpdateTestData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestDataServiceServer).UpdateTestData(ctx, req.(*UpdateTestDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestDataService_DeleteTestData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTestDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestDataServiceServer).DeleteTestData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestDataService_DeleteTestData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestDataServiceServer).DeleteTestData(ctx, req.(*DeleteTestDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestDataService_ListTestData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestDataServiceServer).ListTestData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestDataService_ListTestData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestDataServiceServer).ListTestData(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TestDataService_ServiceDesc is the grpc.ServiceDesc for TestDataService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TestDataService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "storage.TestDataService",
	HandlerType: (*TestDataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTestData",
			Handler:    _TestDataService_CreateTestData_Handler,
		},
		{
			MethodName: "GetTestData",
			Handler:    _TestDataService_GetTestData_Handler,
		},
		{
			MethodName: "UpdateTestData",
			Handler:    _TestDataService_UpdateTestData_Handler,
		},
		{
			MethodName: "DeleteTestData",
			Handler:    _TestDataService_DeleteTestData_Handler,
		},
		{
			MethodName: "ListTestData",
			Handler:    _TestDataService_ListTestData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Storage.proto",
}

const (
	SceneConfigService_CreateSceneConfig_FullMethodName = "/storage.SceneConfigService/CreateSceneConfig"
	SceneConfigService_GetSceneConfig_FullMethodName    = "/storage.SceneConfigService/GetSceneConfig"
	SceneConfigService_UpdateSceneConfig_FullMethodName = "/storage.SceneConfigService/UpdateSceneConfig"
	SceneConfigService_DeleteSceneConfig_FullMethodName = "/storage.SceneConfigService/DeleteSceneConfig"
	SceneConfigService_ListSceneConfigs_FullMethodName  = "/storage.SceneConfigService/ListSceneConfigs"
)

// SceneConfigServiceClient is the client API for SceneConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SceneConfigServiceClient interface {
	// 场景配置
	CreateSceneConfig(ctx context.Context, in *CreateSceneConfigRequest, opts ...grpc.CallOption) (*SceneConfigResponse, error)
	GetSceneConfig(ctx context.Context, in *GetSceneConfigRequest, opts ...grpc.CallOption) (*SceneConfigResponse, error)
	UpdateSceneConfig(ctx context.Context, in *UpdateSceneConfigRequest, opts ...grpc.CallOption) (*SceneConfigResponse, error)
	DeleteSceneConfig(ctx context.Context, in *DeleteSceneConfigRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	ListSceneConfigs(ctx context.Context, in *ListSceneConfigsRequest, opts ...grpc.CallOption) (*SceneConfigListResponse, error)
}

type sceneConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSceneConfigServiceClient(cc grpc.ClientConnInterface) SceneConfigServiceClient {
	return &sceneConfigServiceClient{cc}
}

func (c *sceneConfigServiceClient) CreateSceneConfig(ctx context.Context, in *CreateSceneConfigRequest, opts ...grpc.CallOption) (*SceneConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SceneConfigResponse)
	err := c.cc.Invoke(ctx, SceneConfigService_CreateSceneConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sceneConfigServiceClient) GetSceneConfig(ctx context.Context, in *GetSceneConfigRequest, opts ...grpc.CallOption) (*SceneConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SceneConfigResponse)
	err := c.cc.Invoke(ctx, SceneConfigService_GetSceneConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sceneConfigServiceClient) UpdateSceneConfig(ctx context.Context, in *UpdateSceneConfigRequest, opts ...grpc.CallOption) (*SceneConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SceneConfigResponse)
	err := c.cc.Invoke(ctx, SceneConfigService_UpdateSceneConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sceneConfigServiceClient) DeleteSceneConfig(ctx context.Context, in *DeleteSceneConfigRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, SceneConfigService_DeleteSceneConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sceneConfigServiceClient) ListSceneConfigs(ctx context.Context, in *ListSceneConfigsRequest, opts ...grpc.CallOption) (*SceneConfigListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SceneConfigListResponse)
	err := c.cc.Invoke(ctx, SceneConfigService_ListSceneConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SceneConfigServiceServer is the server API for SceneConfigService service.
// All implementations must embed UnimplementedSceneConfigServiceServer
// for forward compatibility.
type SceneConfigServiceServer interface {
	// 场景配置
	CreateSceneConfig(context.Context, *CreateSceneConfigRequest) (*SceneConfigResponse, error)
	GetSceneConfig(context.Context, *GetSceneConfigRequest) (*SceneConfigResponse, error)
	UpdateSceneConfig(context.Context, *UpdateSceneConfigRequest) (*SceneConfigResponse, error)
	DeleteSceneConfig(context.Context, *DeleteSceneConfigRequest) (*DeleteResponse, error)
	ListSceneConfigs(context.Context, *ListSceneConfigsRequest) (*SceneConfigListResponse, error)
	mustEmbedUnimplementedSceneConfigServiceServer()
}

// UnimplementedSceneConfigServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSceneConfigServiceServer struct{}

func (UnimplementedSceneConfigServiceServer) CreateSceneConfig(context.Context, *CreateSceneConfigRequest) (*SceneConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSceneConfig not implemented")
}
func (UnimplementedSceneConfigServiceServer) GetSceneConfig(context.Context, *GetSceneConfigRequest) (*SceneConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSceneConfig not implemented")
}
func (UnimplementedSceneConfigServiceServer) UpdateSceneConfig(context.Context, *UpdateSceneConfigRequest) (*SceneConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSceneConfig not implemented")
}
func (UnimplementedSceneConfigServiceServer) DeleteSceneConfig(context.Context, *DeleteSceneConfigRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSceneConfig not implemented")
}
func (UnimplementedSceneConfigServiceServer) ListSceneConfigs(context.Context, *ListSceneConfigsRequest) (*SceneConfigListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSceneConfigs not implemented")
}
func (UnimplementedSceneConfigServiceServer) mustEmbedUnimplementedSceneConfigServiceServer() {}
func (UnimplementedSceneConfigServiceServer) testEmbeddedByValue()                            {}

// UnsafeSceneConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SceneConfigServiceServer will
// result in compilation errors.
type UnsafeSceneConfigServiceServer interface {
	mustEmbedUnimplementedSceneConfigServiceServer()
}

func RegisterSceneConfigServiceServer(s grpc.ServiceRegistrar, srv SceneConfigServiceServer) {
	// If the following call pancis, it indicates UnimplementedSceneConfigServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SceneConfigService_ServiceDesc, srv)
}

func _SceneConfigService_CreateSceneConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSceneConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneConfigServiceServer).CreateSceneConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SceneConfigService_CreateSceneConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneConfigServiceServer).CreateSceneConfig(ctx, req.(*CreateSceneConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SceneConfigService_GetSceneConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSceneConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneConfigServiceServer).GetSceneConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SceneConfigService_GetSceneConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneConfigServiceServer).GetSceneConfig(ctx, req.(*GetSceneConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SceneConfigService_UpdateSceneConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSceneConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneConfigServiceServer).UpdateSceneConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SceneConfigService_UpdateSceneConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneConfigServiceServer).UpdateSceneConfig(ctx, req.(*UpdateSceneConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SceneConfigService_DeleteSceneConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSceneConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneConfigServiceServer).DeleteSceneConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SceneConfigService_DeleteSceneConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneConfigServiceServer).DeleteSceneConfig(ctx, req.(*DeleteSceneConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SceneConfigService_ListSceneConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSceneConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SceneConfigServiceServer).ListSceneConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SceneConfigService_ListSceneConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SceneConfigServiceServer).ListSceneConfigs(ctx, req.(*ListSceneConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SceneConfigService_ServiceDesc is the grpc.ServiceDesc for SceneConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SceneConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "storage.SceneConfigService",
	HandlerType: (*SceneConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSceneConfig",
			Handler:    _SceneConfigService_CreateSceneConfig_Handler,
		},
		{
			MethodName: "GetSceneConfig",
			Handler:    _SceneConfigService_GetSceneConfig_Handler,
		},
		{
			MethodName: "UpdateSceneConfig",
			Handler:    _SceneConfigService_UpdateSceneConfig_Handler,
		},
		{
			MethodName: "DeleteSceneConfig",
			Handler:    _SceneConfigService_DeleteSceneConfig_Handler,
		},
		{
			MethodName: "ListSceneConfigs",
			Handler:    _SceneConfigService_ListSceneConfigs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Storage.proto",
}

const (
	ExecuteService_ExecuteTask_FullMethodName = "/storage.ExecuteService/ExecuteTask"
)

// ExecuteServiceClient is the client API for ExecuteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 服务定义
type ExecuteServiceClient interface {
	// 任务执行
	ExecuteTask(ctx context.Context, in *ExecuteTaskRequest, opts ...grpc.CallOption) (*ExecuteTaskResponse, error)
}

type executeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExecuteServiceClient(cc grpc.ClientConnInterface) ExecuteServiceClient {
	return &executeServiceClient{cc}
}

func (c *executeServiceClient) ExecuteTask(ctx context.Context, in *ExecuteTaskRequest, opts ...grpc.CallOption) (*ExecuteTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteTaskResponse)
	err := c.cc.Invoke(ctx, ExecuteService_ExecuteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecuteServiceServer is the server API for ExecuteService service.
// All implementations must embed UnimplementedExecuteServiceServer
// for forward compatibility.
//
// 服务定义
type ExecuteServiceServer interface {
	// 任务执行
	ExecuteTask(context.Context, *ExecuteTaskRequest) (*ExecuteTaskResponse, error)
	mustEmbedUnimplementedExecuteServiceServer()
}

// UnimplementedExecuteServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExecuteServiceServer struct{}

func (UnimplementedExecuteServiceServer) ExecuteTask(context.Context, *ExecuteTaskRequest) (*ExecuteTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteTask not implemented")
}
func (UnimplementedExecuteServiceServer) mustEmbedUnimplementedExecuteServiceServer() {}
func (UnimplementedExecuteServiceServer) testEmbeddedByValue()                        {}

// UnsafeExecuteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExecuteServiceServer will
// result in compilation errors.
type UnsafeExecuteServiceServer interface {
	mustEmbedUnimplementedExecuteServiceServer()
}

func RegisterExecuteServiceServer(s grpc.ServiceRegistrar, srv ExecuteServiceServer) {
	// If the following call pancis, it indicates UnimplementedExecuteServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExecuteService_ServiceDesc, srv)
}

func _ExecuteService_ExecuteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecuteServiceServer).ExecuteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExecuteService_ExecuteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecuteServiceServer).ExecuteTask(ctx, req.(*ExecuteTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExecuteService_ServiceDesc is the grpc.ServiceDesc for ExecuteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExecuteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "storage.ExecuteService",
	HandlerType: (*ExecuteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ExecuteTask",
			Handler:    _ExecuteService_ExecuteTask_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Storage.proto",
}

const (
	InterfaceService_GetInterfaceList_FullMethodName   = "/storage.InterfaceService/GetInterfaceList"
	InterfaceService_GetInterfaceDetail_FullMethodName = "/storage.InterfaceService/GetInterfaceDetail"
	InterfaceService_DeleteInterface_FullMethodName    = "/storage.InterfaceService/DeleteInterface"
	InterfaceService_SyncInterface_FullMethodName      = "/storage.InterfaceService/SyncInterface"
)

// InterfaceServiceClient is the client API for InterfaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InterfaceServiceClient interface {
	// 接口同步
	GetInterfaceList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetInterfaceListResponse, error)
	GetInterfaceDetail(ctx context.Context, in *GetInterfaceRequest, opts ...grpc.CallOption) (*GetInterfaceResponse, error)
	DeleteInterface(ctx context.Context, in *DeleteInterfaceRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	SyncInterface(ctx context.Context, in *SyncInterfaceRequest, opts ...grpc.CallOption) (*SyncInterfaceResponse, error)
}

type interfaceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInterfaceServiceClient(cc grpc.ClientConnInterface) InterfaceServiceClient {
	return &interfaceServiceClient{cc}
}

func (c *interfaceServiceClient) GetInterfaceList(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetInterfaceListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInterfaceListResponse)
	err := c.cc.Invoke(ctx, InterfaceService_GetInterfaceList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) GetInterfaceDetail(ctx context.Context, in *GetInterfaceRequest, opts ...grpc.CallOption) (*GetInterfaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInterfaceResponse)
	err := c.cc.Invoke(ctx, InterfaceService_GetInterfaceDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) DeleteInterface(ctx context.Context, in *DeleteInterfaceRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, InterfaceService_DeleteInterface_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) SyncInterface(ctx context.Context, in *SyncInterfaceRequest, opts ...grpc.CallOption) (*SyncInterfaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncInterfaceResponse)
	err := c.cc.Invoke(ctx, InterfaceService_SyncInterface_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterfaceServiceServer is the server API for InterfaceService service.
// All implementations must embed UnimplementedInterfaceServiceServer
// for forward compatibility.
type InterfaceServiceServer interface {
	// 接口同步
	GetInterfaceList(context.Context, *Empty) (*GetInterfaceListResponse, error)
	GetInterfaceDetail(context.Context, *GetInterfaceRequest) (*GetInterfaceResponse, error)
	DeleteInterface(context.Context, *DeleteInterfaceRequest) (*DeleteResponse, error)
	SyncInterface(context.Context, *SyncInterfaceRequest) (*SyncInterfaceResponse, error)
	mustEmbedUnimplementedInterfaceServiceServer()
}

// UnimplementedInterfaceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInterfaceServiceServer struct{}

func (UnimplementedInterfaceServiceServer) GetInterfaceList(context.Context, *Empty) (*GetInterfaceListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInterfaceList not implemented")
}
func (UnimplementedInterfaceServiceServer) GetInterfaceDetail(context.Context, *GetInterfaceRequest) (*GetInterfaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInterfaceDetail not implemented")
}
func (UnimplementedInterfaceServiceServer) DeleteInterface(context.Context, *DeleteInterfaceRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInterface not implemented")
}
func (UnimplementedInterfaceServiceServer) SyncInterface(context.Context, *SyncInterfaceRequest) (*SyncInterfaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncInterface not implemented")
}
func (UnimplementedInterfaceServiceServer) mustEmbedUnimplementedInterfaceServiceServer() {}
func (UnimplementedInterfaceServiceServer) testEmbeddedByValue()                          {}

// UnsafeInterfaceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InterfaceServiceServer will
// result in compilation errors.
type UnsafeInterfaceServiceServer interface {
	mustEmbedUnimplementedInterfaceServiceServer()
}

func RegisterInterfaceServiceServer(s grpc.ServiceRegistrar, srv InterfaceServiceServer) {
	// If the following call pancis, it indicates UnimplementedInterfaceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InterfaceService_ServiceDesc, srv)
}

func _InterfaceService_GetInterfaceList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).GetInterfaceList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterfaceService_GetInterfaceList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).GetInterfaceList(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_GetInterfaceDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).GetInterfaceDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterfaceService_GetInterfaceDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).GetInterfaceDetail(ctx, req.(*GetInterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_DeleteInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).DeleteInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterfaceService_DeleteInterface_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).DeleteInterface(ctx, req.(*DeleteInterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_SyncInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncInterfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).SyncInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterfaceService_SyncInterface_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).SyncInterface(ctx, req.(*SyncInterfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InterfaceService_ServiceDesc is the grpc.ServiceDesc for InterfaceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InterfaceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "storage.InterfaceService",
	HandlerType: (*InterfaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInterfaceList",
			Handler:    _InterfaceService_GetInterfaceList_Handler,
		},
		{
			MethodName: "GetInterfaceDetail",
			Handler:    _InterfaceService_GetInterfaceDetail_Handler,
		},
		{
			MethodName: "DeleteInterface",
			Handler:    _InterfaceService_DeleteInterface_Handler,
		},
		{
			MethodName: "SyncInterface",
			Handler:    _InterfaceService_SyncInterface_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Storage.proto",
}

const (
	GenerateService_GenerateDependency_FullMethodName = "/storage.GenerateService/GenerateDependency"
	GenerateService_GenerateExtractor_FullMethodName  = "/storage.GenerateService/GenerateExtractor"
	GenerateService_GenerateExpect_FullMethodName     = "/storage.GenerateService/GenerateExpect"
)

// GenerateServiceClient is the client API for GenerateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GenerateServiceClient interface {
	// 根据ApiInfo生成依赖、提取器、预期
	GenerateDependency(ctx context.Context, in *GenerateDependencyRequest, opts ...grpc.CallOption) (*GenerateDependencyResponse, error)
	GenerateExtractor(ctx context.Context, in *GenerateExtractorRequest, opts ...grpc.CallOption) (*GenerateExtractorResponse, error)
	GenerateExpect(ctx context.Context, in *GenerateExpectRequest, opts ...grpc.CallOption) (*GenerateExpectResponse, error)
}

type generateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGenerateServiceClient(cc grpc.ClientConnInterface) GenerateServiceClient {
	return &generateServiceClient{cc}
}

func (c *generateServiceClient) GenerateDependency(ctx context.Context, in *GenerateDependencyRequest, opts ...grpc.CallOption) (*GenerateDependencyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateDependencyResponse)
	err := c.cc.Invoke(ctx, GenerateService_GenerateDependency_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *generateServiceClient) GenerateExtractor(ctx context.Context, in *GenerateExtractorRequest, opts ...grpc.CallOption) (*GenerateExtractorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateExtractorResponse)
	err := c.cc.Invoke(ctx, GenerateService_GenerateExtractor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *generateServiceClient) GenerateExpect(ctx context.Context, in *GenerateExpectRequest, opts ...grpc.CallOption) (*GenerateExpectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateExpectResponse)
	err := c.cc.Invoke(ctx, GenerateService_GenerateExpect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GenerateServiceServer is the server API for GenerateService service.
// All implementations must embed UnimplementedGenerateServiceServer
// for forward compatibility.
type GenerateServiceServer interface {
	// 根据ApiInfo生成依赖、提取器、预期
	GenerateDependency(context.Context, *GenerateDependencyRequest) (*GenerateDependencyResponse, error)
	GenerateExtractor(context.Context, *GenerateExtractorRequest) (*GenerateExtractorResponse, error)
	GenerateExpect(context.Context, *GenerateExpectRequest) (*GenerateExpectResponse, error)
	mustEmbedUnimplementedGenerateServiceServer()
}

// UnimplementedGenerateServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGenerateServiceServer struct{}

func (UnimplementedGenerateServiceServer) GenerateDependency(context.Context, *GenerateDependencyRequest) (*GenerateDependencyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDependency not implemented")
}
func (UnimplementedGenerateServiceServer) GenerateExtractor(context.Context, *GenerateExtractorRequest) (*GenerateExtractorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateExtractor not implemented")
}
func (UnimplementedGenerateServiceServer) GenerateExpect(context.Context, *GenerateExpectRequest) (*GenerateExpectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateExpect not implemented")
}
func (UnimplementedGenerateServiceServer) mustEmbedUnimplementedGenerateServiceServer() {}
func (UnimplementedGenerateServiceServer) testEmbeddedByValue()                         {}

// UnsafeGenerateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GenerateServiceServer will
// result in compilation errors.
type UnsafeGenerateServiceServer interface {
	mustEmbedUnimplementedGenerateServiceServer()
}

func RegisterGenerateServiceServer(s grpc.ServiceRegistrar, srv GenerateServiceServer) {
	// If the following call pancis, it indicates UnimplementedGenerateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GenerateService_ServiceDesc, srv)
}

func _GenerateService_GenerateDependency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateDependencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GenerateServiceServer).GenerateDependency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GenerateService_GenerateDependency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GenerateServiceServer).GenerateDependency(ctx, req.(*GenerateDependencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GenerateService_GenerateExtractor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateExtractorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GenerateServiceServer).GenerateExtractor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GenerateService_GenerateExtractor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GenerateServiceServer).GenerateExtractor(ctx, req.(*GenerateExtractorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GenerateService_GenerateExpect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateExpectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GenerateServiceServer).GenerateExpect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GenerateService_GenerateExpect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GenerateServiceServer).GenerateExpect(ctx, req.(*GenerateExpectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GenerateService_ServiceDesc is the grpc.ServiceDesc for GenerateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GenerateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "storage.GenerateService",
	HandlerType: (*GenerateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateDependency",
			Handler:    _GenerateService_GenerateDependency_Handler,
		},
		{
			MethodName: "GenerateExtractor",
			Handler:    _GenerateService_GenerateExtractor_Handler,
		},
		{
			MethodName: "GenerateExpect",
			Handler:    _GenerateService_GenerateExpect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Storage.proto",
}
